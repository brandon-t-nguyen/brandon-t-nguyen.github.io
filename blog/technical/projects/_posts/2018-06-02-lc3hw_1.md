---
title: "Project: lc3-hw [1]: Building some building blocks"
layout: post
author: Brandon Nguyen
categories: [technical, projects]
tags: [digital logic, fpga, verilog]
excerpt_separator: <!--more-->
---

*This post is a copy from my old website and blog. I have kept its original post date.*

Before I head off and implement the CPU itself, it’s important to realize that we’re going to need the other parts of the computer system,
such as memory, registers and buses etc.
In this post, I’ll be discussing the first few Verilog modules that I created in order to enable implementing the overall system.
Since there is already a baseline microarchitecture done complete with control signals,
I thought it’d be prudent to come up with modules that corresponded to the various structures present.
However, I most likely will be implementing the CPU logic in behavioral Verilog.

I’m intending on enabling a structural implementation of the LC-3 system overall, with the components being modeled as behavioral or as dataflow.
Since this is intended on being put onto an FPGA, I’ll leave it at those two, since the synthesizer should be able to infer the structures and
figure out the optimal way to implement them (e.g. FPGAs already have flip-flop and mux resources: no need to define them at the gate level).

## Tristate Buffer
First off is a tristate buffer: this nifty guy is what keeps buses from being a polluted mess of signals with all the things that could be writing to it.
It effectively acts as a switch allowing data to pass through when enabled and outputting a high-impedance when not enabled.
While there is a `tri` type in Verilog, it really is just an aliased `wire` and is more for documentation purposes.
I’ll be giving it two versions: an active-high enable and an active-low enable.

![](https://en.wikipedia.org/wiki/Three-state_logic#/media/File:Tristate_buffer.svg){:widcth="100%"}

\<copying to be finished\>
